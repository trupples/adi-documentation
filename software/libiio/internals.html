<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>About libiio &#8212; System Level Documentation  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8e8a900e" />
    <link rel="stylesheet" type="text/css" href="../../_static/app.min.css?v=c218d0f6" />
    <script defer="" src="../../_static/app.umd.js?v=5e042acc"></script>
    <link rel="icon" href="../../_static/icon.svg"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Libiio command line utility" href="cli.html" />
    <link rel="prev" title="Libiio" href="index.html" />
   
  
  <meta name="repository" content="documentation">
  <meta name="version" content="">
  
    <meta name="page_source_suffix" content=".rst">
  
  


<style>
  body {
    
  }

  body.dark {
    
  }

  @media (prefers-color-scheme: dark) {
    body:not(.light) {
      
    }
  }
</style>
  </head><body>
  <input type="checkbox" id="input-show-toc">
  <input type="checkbox" id="input-show-localtoc">
  <input type="checkbox" id="input-show-repotoc">

  
  <div class="search-area">
    <form action="" method="get">
      <input type="text" name="q" aria-labelledby="search-documentation" value="" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="search" placeholder="Search"/>
      <button class="icon"></button>
    </form>
  </div>
  

  <header>
    <div id="left">
      <label id="show-sidebar" class="icon" for="input-show-toc" title="Show/hide index"></label>
    </div>
    <div id="right">
      <span>
        <a id="logo-org" href="https://analog.com"></a>
        <div class="vertical-divider"></div>
        <label id="show-repotoc" for="input-show-repotoc" title="Show/hide docs" tabindex="0">Docs</label>
        <a id="logo" href="../../index.html">
          <div>System Level</div>
        </a>
      </span>
      <span class="reverse">
        <label id="show-localtoc" class="icon" for="input-show-localtoc" title="Show/hide contents"></label>
      </span>
    </div>
  </header>


  <div class="repotoc-tree overlay">
    <root>
  <a href="../../index.html" class="current">System Level</a>
</root>

  </div>
    <div class="localtoc">
      <div class="tocwrapper">
        <div>
          <div class="localtoc-header"></div>
          <a id="scroll-up" href="#top-anchor" title="Back to top"></a>
        </div>
        <nav>
          <ul>
<li><a class="reference internal" href="#">About libiio</a><ul>
<li><a class="reference internal" href="#objectives">Objectives</a><ul>
<li><a class="reference internal" href="#simplification-and-standardization">Simplification and standardization</a></li>
<li><a class="reference internal" href="#advanced-features">Advanced features</a></li>
</ul>
</li>
<li><a class="reference internal" href="#license-and-code-management">License and code management</a></li>
<li><a class="reference internal" href="#code-conformance">Code conformance</a></li>
<li><a class="reference internal" href="#code-visibility">Code visibility</a></li>
<li><a class="reference internal" href="#backends">Backends</a></li>
<li><a class="reference internal" href="#layering">Layering</a></li>
<li><a class="reference internal" href="#the-xml-and-local-backends">The XML and local backends</a><ul>
<li><a class="reference internal" href="#the-xml-backend">The XML backend</a><ul>
<li><a class="reference internal" href="#document-type-definition">Document Type Definition</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-local-backend">The local backend</a><ul>
<li><a class="reference internal" href="#creation-of-the-context-from-sysfs">Creation of the context from sysfs</a></li>
<li><a class="reference internal" href="#parsing-issues">Parsing issues</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#reading-and-writing">Reading and writing</a><ul>
<li><a class="reference internal" href="#enabling-channels">Enabling channels</a></li>
<li><a class="reference internal" href="#creating-a-buffer">Creating a buffer</a></li>
<li><a class="reference internal" href="#reading-and-writing-the-old-way">Reading and writing, the old way</a></li>
<li><a class="reference internal" href="#reading-and-writing-with-the-iio-buffer-class">Reading and writing with the iio_buffer class</a></li>
<li><a class="reference internal" href="#refilling-and-submitting-a-buffer">Refilling and submitting a buffer</a></li>
<li><a class="reference internal" href="#format-conversion">Format conversion</a></li>
<li><a class="reference internal" href="#low-speed-interface">Low-speed interface</a></li>
<li><a class="reference internal" href="#high-speed-mmap-interface">High-speed mmap interface</a></li>
<li><a class="reference internal" href="#cyclic-buffers">Cyclic buffers</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-network-backend-and-iio-daemon">The network backend and IIO Daemon</a><ul>
<li><a class="reference internal" href="#conception-of-the-iio-daemon">Conception of the IIO Daemon</a><ul>
<li><a class="reference internal" href="#why-a-network-backend">Why a network backend?</a></li>
<li><a class="reference internal" href="#challenges">Challenges</a></li>
<li><a class="reference internal" href="#far-distance-view">Far-distance view</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-command-interpreter">The command interpreter</a><ul>
<li><a class="reference internal" href="#flex-bison">Flex, Bison</a></li>
<li><a class="reference internal" href="#protocol">Protocol</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sending-and-receiving-samples">Sending and receiving samples</a><ul>
<li><a class="reference internal" href="#opening-a-device">Opening a device</a></li>
<li><a class="reference internal" href="#the-read-write-thread">The read/write thread</a></li>
<li><a class="reference internal" href="#data-transfer">Data transfer</a></li>
<li><a class="reference internal" href="#server-side-and-client-side-de-multiplexing">Server-side and client-side de-multiplexing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-network-backend">The network backend</a><ul>
<li><a class="reference internal" href="#sending-and-receiving-commands">Sending and receiving commands</a></li>
<li><a class="reference internal" href="#context-creation">Context creation</a></li>
<li><a class="reference internal" href="#zero-configuration">Zero-configuration</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#libiio-now-and-in-the-future">Libiio, now and in the future</a><ul>
<li><a class="reference internal" href="#bindings">Bindings</a><ul>
<li><a class="reference internal" href="#python-bindings">Python bindings</a><ul>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#pyadi-iio">PyADI-IIO</a></li>
</ul>
</li>
<li><a class="reference internal" href="#c-bindings">C# bindings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#future-improvements">Future improvements</a><ul>
<li><a class="reference internal" href="#zerocopy">Zerocopy</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </nav>
      </div>
    </div>

  
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
    <a id="no-logo" href="../../index.html">
      System Level Documentation
    </a><input id="input-switch-toc" type="checkbox">
<label id="show-repotoc" for="input-switch-toc">
All content
</label>
<label id="show-toc" for="input-switch-toc">
Content on this topic
</label>
<div class="repotoc-tree">
  <root>
  <a href="../../index.html" class="current">System Level</a>
</root>

</div>
<div class="toc-tree">
  <html>
  <body><p class="caption" role="heading"><span class="caption-text">Kuiper &amp; Linux Kernel</span></p>
<ul>
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-1" id="toctree-collapse-1"/><div class="collapse"><a class="reference internal" href="../../linux/drivers/index.html">Linux drivers</a><label for="toctree-collapse-1"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-1-1" id="toctree-collapse-1-1"/><div class="collapse"><a class="reference internal" href="../../linux/drivers/iio-adc/index.html">IIO ADC</a><label for="toctree-collapse-1-1"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../linux/drivers/iio-adc/ad4052/index.html">AD4052</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../linux/drivers/iio-adc/ad9084/index.html">AD9084/AD9088</a></li>
</ul>
</li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-1-2" id="toctree-collapse-1-2"/><div class="collapse"><a class="reference internal" href="../../linux/drivers/iio-transceiver/index.html">IIO Transceivers</a><label for="toctree-collapse-1-2"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-1-2-1" id="toctree-collapse-1-2-1"/><div class="collapse"><a class="reference internal" href="../../linux/drivers/iio-transceiver/adrv9009/index.html">ADRV9009, ADRV9008-1, ADRV9008-2</a><label for="toctree-collapse-1-2-1"><div class="icon"></div></label></div><ul>
<li class="toctree-l4"><a class="reference internal" href="../../linux/drivers/iio-transceiver/adrv9009/customization.html">Customization</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-1-3" id="toctree-collapse-1-3"/><div class="collapse"><a class="reference internal" href="../../linux/drivers/iio/index.html">Linux Industrial I/O Subsystem</a><label for="toctree-collapse-1-3"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../linux/drivers/iio/iio-trig-sysfs.html">iio-trig-sysfs driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../linux/drivers/iio/iio-trig-bfin-timer.html">iio-trig-bfin-timer driver</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-2" id="toctree-collapse-2"/><div class="collapse"><a class="reference internal" href="../../linux/kernel/index.html">Kernel and devicetrees</a><label for="toctree-collapse-2"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><a class="reference internal" href="../../linux/kernel/zynq.html">Build Zynq</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../linux/kernel/zynqmp.html">Build ZynqMP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../linux/kernel/microblaze.html">Build MicroBlaze</a></li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-2-1" id="toctree-collapse-2-1"/><div class="collapse"><a class="reference internal" href="../../linux/kernel/petalinux.html">Build with Petalinux</a><label for="toctree-collapse-2-1"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-2-1-1" id="toctree-collapse-2-1-1"/><div class="collapse"><a class="reference internal" href="../../linux/kernel/petalinux-dts/index.html">Petalinux Device Trees</a><label for="toctree-collapse-2-1-1"><div class="icon"></div></label></div><ul>
<li class="toctree-l4"><a class="reference internal" href="../../linux/kernel/petalinux-dts/petalinux-custom-dts.html">Custom Device Trees with meta-adi</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../linux/kernel/petalinux-dts/petalinux-meta-adi-bypass.html">Custom Device Trees with DTG (meta-adi Bypass)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../linux/kernel/petalinux-dts/petalinux-system-user.html">Device Tree Modifications with system-user.dtsi</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-3" id="toctree-collapse-3"/><div class="collapse"><a class="reference internal" href="../../linux/kuiper/index.html">Kuiper Linux</a><label for="toctree-collapse-3"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><a class="reference internal" href="../../linux/kuiper/release-notes.html">Release notes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../linux/kuiper/sdcard/index.html">SD Card flashing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../linux/kuiper/project-list.html">Project list</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../linux/kuiper/update.html">Updating</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Software</span></p>
<ul class="current">
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-4" id="toctree-collapse-4"/><div class="collapse"><a class="reference internal" href="../iio-oscilloscope/index.html">IIO Oscilloscope</a><label for="toctree-collapse-4"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-4-1" id="toctree-collapse-4-1"/><div class="collapse"><a class="reference internal" href="../iio-oscilloscope/adrv9009/index.html">ADRV9009</a><label for="toctree-collapse-4-1"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../iio-oscilloscope/adrv9009/plugin.html">Standard Plugin</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iio-oscilloscope/adrv9009/advanced-plugin.html">Advanced plugin</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-5" id="toctree-collapse-5" checked=""/><div class="collapse"><a class="reference internal" href="index.html">Libiio</a><label for="toctree-collapse-5"><div class="icon"></div></label></div><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">About libiio</a></li>
<li class="toctree-l2"><a class="reference internal" href="cli.html">Command line utility</a></li>
<li class="toctree-l2"><a class="reference internal" href="tips-tricks.html">Tips &amp; Tricks</a></li>
</ul>
</li>
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-6" id="toctree-collapse-6"/><div class="collapse"><a class="reference internal" href="../libm2k/index.html">Libm2k</a><label for="toctree-collapse-6"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><a class="reference internal" href="../libm2k/calibration.html">Calibration</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libm2k/digital_communication.html">Digital communication</a></li>
<li class="toctree-l2"><a class="reference internal" href="../libm2k/m2kcli.html">Command line utility</a></li>
</ul>
</li>
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-7" id="toctree-collapse-7"/><div class="collapse"><a class="reference internal" href="../matlab/index.html">MATLAB &amp; Simulink Toolboxes</a><label for="toctree-collapse-7"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><a class="reference internal" href="../matlab/hsx-toolbox/index.html">High Speed Converter Toolbox</a></li>
<li class="toctree-l2"><a class="reference internal" href="../matlab/transceiver-toolbox/index.html">Transceiver Toolbox</a></li>
<li class="toctree-l2"><a class="reference internal" href="../matlab/bsp-extend.html">Extending Device Interfaces</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../pyadi-iio/index.html">PyADI-IIO</a></li>
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-8" id="toctree-collapse-8"/><div class="collapse"><a class="reference internal" href="../zephyr/index.html">Zephyr RTOS</a><label for="toctree-collapse-8"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><a class="reference internal" href="../zephyr/zephyr-devicetree.html">Intro to Devicetree</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zephyr/kconfig/zephyr-kconfig.html">Introduction to Kconfig</a></li>
<li class="toctree-l2"><a class="reference internal" href="../zephyr/using-zephyr-codefusion-fs/zephyr_codefusion_fs.html">Using Zephyr &amp; Codefusion Studio to Partition a Flash Filesystem</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Evaluation Boards</span></p>
<ul>
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-9" id="toctree-collapse-9"/><div class="collapse"><a class="reference internal" href="../../eval/user-guide/index.html">User guides</a><label for="toctree-collapse-9"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-9-1" id="toctree-collapse-9-1"/><div class="collapse"><a class="reference internal" href="../../eval/user-guide/adc/ad4052-ardz/index.html">EVAL-AD4050/AD4052-ARDZ</a><label for="toctree-collapse-9-1"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../eval/user-guide/adc/ad4052-ardz/user-guide.html">Evaluating the device</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../eval/user-guide/adc/ad9084-ebz/index.html">EVAL-AD9084-EBZ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../eval/user-guide/mem/adxl355-pmdz/index.html">EVAL-ADXL355-PMDZ</a></li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-9-2" id="toctree-collapse-9-2"/><div class="collapse"><a class="reference internal" href="../../eval/user-guide/transceiver/adrv9009/index.html">ADRV9009 &amp; ADRV9008</a><label for="toctree-collapse-9-2"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../eval/user-guide/transceiver/adrv9009/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l3"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-9-2-1" id="toctree-collapse-9-2-1"/><div class="collapse"><a class="reference internal" href="../../eval/user-guide/transceiver/adrv9009/quickstart/index.html">Quickstart</a><label for="toctree-collapse-9-2-1"><div class="icon"></div></label></div><ul>
<li class="toctree-l4"><a class="reference internal" href="../../eval/user-guide/transceiver/adrv9009/quickstart/zynqmp.html">ZCU102</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../eval/user-guide/transceiver/adrv9009/basic-iq-datafiles.html">Basic IQ Datafiles</a></li>
</ul>
</li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-9-3" id="toctree-collapse-9-3"/><div class="collapse"><a class="reference internal" href="../../eval/user-guide/transceiver/adrv9026/index.html">ADRV9026 &amp; ADRV9029</a><label for="toctree-collapse-9-3"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../eval/user-guide/transceiver/adrv9026/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l3"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-9-3-1" id="toctree-collapse-9-3-1"/><div class="collapse"><a class="reference internal" href="../../eval/user-guide/transceiver/adrv9026/quickstart/index.html">Quickstart</a><label for="toctree-collapse-9-3-1"><div class="icon"></div></label></div><ul>
<li class="toctree-l4"><a class="reference internal" href="../../eval/user-guide/transceiver/adrv9026/quickstart/zynqmp.html">ZCU102</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../eval/user-guide/transceiver/adrv9026/quickstart/versal.html">VCK190</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Products &amp; Tools</span></p>
<ul>
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-10" id="toctree-collapse-10"/><div class="collapse"><a class="reference internal" href="../../tools/m2k/index.html">ADALM2000</a><label for="toctree-collapse-10"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tools/m2k/devs/index.html">For Developers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/m2k/users/index.html">For End Users</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/m2k/help_support.html">Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/m2k/labview.html">Using With LabVIEW</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/m2k/matlab.html">Using with MATLAB</a></li>
</ul>
</li>
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-11" id="toctree-collapse-11"/><div class="collapse"><a class="reference internal" href="../../tools/pluto-m2k/index.html">Common PLUTO&amp;M2K</a><label for="toctree-collapse-11"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tools/pluto-m2k/building_the_image.html">Building the Firmware Image</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/pluto-m2k/drivers.html">Installing Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/pluto-m2k/firmware.html">Firmware Updates</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/pluto-m2k/obtaining_the_sources.html">Obtaining the Build Sources</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/pluto-m2k/reboot.html">Rebooting</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/pluto-m2k/usb_otg_host.html">USB OTG – HOST function Support</a></li>
</ul>
</li>
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-12" id="toctree-collapse-12"/><div class="collapse"><a class="reference internal" href="../../tools/pluto/index.html">ADALM-PLUTO</a><label for="toctree-collapse-12"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-12-1" id="toctree-collapse-12-1"/><div class="collapse"><a class="reference internal" href="../../tools/pluto/devs/index.html">For Developers</a><label for="toctree-collapse-12-1"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/pluto/devs/usb_otg.html">USB OTG</a></li>
</ul>
</li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-12-2" id="toctree-collapse-12-2"/><div class="collapse"><a class="reference internal" href="../../tools/pluto/hacking/index.html">For Hackers</a><label for="toctree-collapse-12-2"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/pluto/hacking/hardware.html">ADALM-PLUTO Hardware</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/pluto/hacking/listening_to_yourself.html">Self Reception</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../tools/pluto/hacking/power_amp.html">Controlling External Devices</a></li>
</ul>
</li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-12-3" id="toctree-collapse-12-3"/><div class="collapse"><a class="reference internal" href="../../tools/pluto/users/index.html">For End Users</a><label for="toctree-collapse-12-3"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tools/pluto/users/antennas.html">Antennas</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/pluto/help_support.html">Support</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/pluto/prerequisites.html">Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tools/pluto/transceiver_transferring_data.html">Controlling the transceiver and transferring data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tools/uartjtag/index.html">ADALM-UARTJTAG</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Apps &amp; Solutions</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../solutions/application-software/index.html">Application Software</a></li>
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-13" id="toctree-collapse-13"/><div class="collapse"><a class="reference internal" href="../../solutions/reference-designs/index.html">Reference Designs</a><label for="toctree-collapse-13"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-13-1" id="toctree-collapse-13-1"/><div class="collapse"><a class="reference internal" href="../../solutions/reference-designs/ad-amr-bms-sl/index.html">AD-AMR-BMS-SL (partno TBD)</a><label for="toctree-collapse-13-1"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-amr-bms-sl/od.html">AD-AMR-BMS-SL CANopen Object Dictionary</a></li>
</ul>
</li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-13-2" id="toctree-collapse-13-2"/><div class="collapse"><a class="reference internal" href="../../solutions/reference-designs/ad-amr-drv-sl/index.html">AD-AMR-DRV-SL (partno TBD)</a><label for="toctree-collapse-13-2"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-amr-drv-sl/od.html">AD-AMR-DRV-SL CANopen Object Dictionary</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../solutions/reference-designs/ad-amr-loc-rpiz/index.html">AD-AMR-LOC-RPIZ</a></li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-13-3" id="toctree-collapse-13-3"/><div class="collapse"><a class="reference internal" href="../../solutions/reference-designs/ad-apard32690-sl/index.html">AD-APARD32690-SL</a><label for="toctree-collapse-13-3"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-apard32690-sl/ad-t1lusb-ebz/index.html">AD-T1LUSB2.0-EBZ</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-apard32690-sl/nina-w102/index.html">NINA-W102 Networking Support</a></li>
</ul>
</li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-13-4" id="toctree-collapse-13-4"/><div class="collapse"><a class="reference internal" href="../../solutions/reference-designs/ad-bmse2e3w-sl/index.html">AD-BMSE2E3W-SL</a><label for="toctree-collapse-13-4"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-bmse2e3w-sl/sample_application/index.html">Sample Application</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-bmse2e3w-sl/software_guide/index.html">Software User Guide</a></li>
</ul>
</li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-13-5" id="toctree-collapse-13-5"/><div class="collapse"><a class="reference internal" href="../../solutions/reference-designs/ad-cellpackbm-sl/index.html">AD-CELLPACKBM-SL</a><label for="toctree-collapse-13-5"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-cellpackbm-sl/hardware_guide/index.html">Hardware User Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-cellpackbm-sl/software_guide/index.html">Software User Guide</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../solutions/reference-designs/ad-gmsl-d-e-adp/index.html">AD-GMSL-D-E-ADP#</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../solutions/reference-designs/ad-gmsl2eth-sl/index.html">AD-GMSL2ETH-SL</a></li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-13-6" id="toctree-collapse-13-6"/><div class="collapse"><a class="reference internal" href="../../solutions/reference-designs/ad-gmsl522-sl/index.html">AD-GMSL522-SL</a><label for="toctree-collapse-13-6"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-gmsl522-sl/hardware-guide/index.html">Hardware Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-gmsl522-sl/software-guide/index.html">Software Guide</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../solutions/reference-designs/ad-gmsl717mipi-evk/index.html">AD-GMSL717MIPI-EVK</a></li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-13-7" id="toctree-collapse-13-7"/><div class="collapse"><a class="reference internal" href="../../solutions/reference-designs/ad-gmslcamrpi-adp/index.html">AD-GMSLCAMRPI-ADP#</a><label for="toctree-collapse-13-7"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-gmslcamrpi-adp/amd-kria/index.html">Using with AMD Kria</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-gmslcamrpi-adp/nvidia-jetson/index.html">Using with Nvidia Jetson Orin Nano</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-gmslcamrpi-adp/raspberry-pi-user-guide/index.html">Using with Raspberry Pi</a></li>
</ul>
</li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-13-8" id="toctree-collapse-13-8"/><div class="collapse"><a class="reference internal" href="../../solutions/reference-designs/ad-swiot1l-sl/index.html">AD-SWIOT1L-SL</a><label for="toctree-collapse-13-8"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-swiot1l-sl/hardware-guide/index.html">Hardware User Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/ad-swiot1l-sl/software-guide/index.html">Software User Guide</a></li>
</ul>
</li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-13-9" id="toctree-collapse-13-9"/><div class="collapse"><a class="reference internal" href="../../solutions/reference-designs/eval-ad-amr/index.html">EVAL-AD-AMR</a><label for="toctree-collapse-13-9"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/eval-ad-amr/diy-setup.html">EVAL-AD-AMR Hardware Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/eval-ad-amr/ros2-architecture.html">EVAL-AD-AMR ROS2 architecture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/eval-ad-amr/ros2-examples.html">EVAL-AD-AMR ROS2 examples</a></li>
</ul>
</li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-13-10" id="toctree-collapse-13-10"/><div class="collapse"><a class="reference internal" href="../../solutions/reference-designs/eval-cn0503-ardz/index.html">EVAL-CN0503-ARDZ</a><label for="toctree-collapse-13-10"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/eval-cn0503-ardz/cn0503-software/index.html">Software User Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/eval-cn0503-ardz/fluorescence-measurement/index.html">Fluorescence Measurement Demo</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/eval-cn0503-ardz/nitrate-measurement/index.html">Nitrate Measurement Demo</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/eval-cn0503-ardz/pH-measurement/index.html">pH Measurement Demo</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/eval-cn0503-ardz/turbidity/index.html">Turbidity Measurement Demo</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../solutions/reference-designs/eval-cn0565-ardz/index.html">EVAL-CN0565-ARDZ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../solutions/reference-designs/eval-cn0575-rpiz/index.html">EVAL-CN0575-RPIZ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../solutions/reference-designs/eval-cn0577-fmcz/index.html">EVAL-CN0577-FMCZ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../solutions/reference-designs/eval-ess1-sys/index.html">EVAL-ESS1-SYS</a></li>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-13-11" id="toctree-collapse-13-11"/><div class="collapse"><a class="reference internal" href="../../solutions/reference-designs/eval-isomax/index.html">EVAL-ISOMAX</a><label for="toctree-collapse-13-11"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/eval-isomax/hardware_guide/index.html">Hardware User Guide</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../solutions/reference-designs/eval-isomax/software_guide/index.html">Software User Guide</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">University Program</span></p>
<ul>
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-14" id="toctree-collapse-14"/><div class="collapse"><a class="reference internal" href="../../university/index.html">Engineering University Program</a><label for="toctree-collapse-14"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-14-1" id="toctree-collapse-14-1"/><div class="collapse"><a class="reference internal" href="../../university/active_learning/index.html">Active Learning: Student-oriented Lab Exercises</a><label for="toctree-collapse-14-1"><div class="icon"></div></label></div><ul>
<li class="toctree-l3"><a class="reference internal" href="../../university/active_learning/wien_bridge_oscillator/index.html">Activity: The Wien Bridge Oscillator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../university/active_learning/efficiency_power_loss/index.html">Activity: Efficiency, Power Loss, and Thermal Management</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Learning</span></p>
<ul>
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-15" id="toctree-collapse-15"/><div class="collapse"><a class="reference internal" href="../../learning/index.html">Learning! Tutorials, Workshops, Etc</a><label for="toctree-collapse-15"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><a class="reference internal" href="../../learning/tutorial_prec_adc/index.html">Precision ADC Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../learning/converter_connectivity_tutorial/index.html">Converter Connectivity Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../learning/sw_infrastructure/index.html">Software Infrastructure for designing with ADCs, DACs, and Sensors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../learning/tools_for_ls/index.html">Tools for Low Speed Mixed Signal System Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../learning/tools_for_prec_wb/index.html">Tools for Precision Wideband Mixed Signal System Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../learning/tools_for_hs/index.html">Tools for High-Speed Mixed Signal System Design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../learning/workshop_what_sw_for_sdr/index.html">What software do I need for my SDR?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../learning/workshops_software_defined_instrumentation/index.html">Software Defined Instrumentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../learning/workshops_introduction_to_electronics/index.html">Introduction to Electronics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../learning/workshops_embedded_baremetal/index.html">Embedded Baremetal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../learning/workshops_embedded_linux/index.html">Embedded Linux</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contributing and Guidelines</span></p>
<ul>
<li class="toctree-l1"><input class="toctree-collapse" type="checkbox" name="toctree-collapse-16" id="toctree-collapse-16"/><div class="collapse"><a class="reference internal" href="../../contributing/creating_new_pages.html">Creating new pages</a><label for="toctree-collapse-16"><div class="icon"></div></label></div><ul>
<li class="toctree-l2"><a class="reference internal" href="../../contributing/template/eval.html">Evaluation Boards</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/docs_guidelines.html">Documentation guidelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/forking_publishing.html">Forking and publishing</a></li>
</ul>
</body>
</html>

</div>
        </div>
      </div>

  <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper" id="top-anchor">
          <div class="body-header">
    <nav class="breadcrumb">
        <ol>
          <li><a href="index.html">Libiio</a></li>
          </ol>
    </nav>
  </div>

          <div class="body" role="main">
            
  <section id="about-libiio">
<span id="libiio-internals"></span><h1>About libiio<a class="headerlink" href="#about-libiio" title="Link to this heading"></a></h1>
<section id="objectives">
<h2>Objectives<a class="headerlink" href="#objectives" title="Link to this heading"></a></h2>
<p>Why did Analog Devices develop libiio? To answer that question, it is needed to
understand the state of things before libiio was introduced.</p>
<section id="simplification-and-standardization">
<h3>Simplification and standardization<a class="headerlink" href="#simplification-and-standardization" title="Link to this heading"></a></h3>
<p>The Linux kernel features a IIO subsystem, which provides a standardized
interface with the user-space for client applications. The various drivers
designed to interface different IIO devices register with the IIO subsystem. As
a result, all supported devices can be used by user-space applications with the
same interface.</p>
<p>At least, that’s the theory. The reality is more complex; the interface provides
different ways to read or write a device, each driver generally implementing
only the oldest and slowest method. The various drivers will also create
slightly different files in the sysfs filesystem of Linux, where all the virtual
files used to configure the interface are present.</p>
<p>As a result, before libiio was born the applications using IIO devices would
generally be designed to support only one particular device, because it was too
much work to support several at a time. Because of this, a lot of applications
had their own code to interface with the kernel’s IIO subsystem leading to
maintenance issues. Furthermore, it was very difficult for customers to create
applications to use their hardware since they had to continuously rewrite the
interface code or adapt it from a pre-existing application.</p>
<p>The objective behind libiio is to ease the development process of applications
using IIO devices, by letting the new library be the intermediate between the
program and the kernel.</p>
<p>By cleverly identifying devices, available input or output channels, libiio
allows one application to support a wide range of devices. For instance, if the
application requests one device that features a capture channel without
specifying its name, then it will be compatible with all IIO devices with at
least one capture channel that exist to date, as well as future hardware that
has yet to be invented.</p>
</section>
<section id="advanced-features">
<h3>Advanced features<a class="headerlink" href="#advanced-features" title="Link to this heading"></a></h3>
<p>Beyond resolving issues, libiio was also announcing new features. The major
planned improvement being a network backend, which would broaden the set of
possibilities: running the applications as a single user, reading one IIO device
from different applications, and of course use a device from anywhere in the
network in an application.</p>
<p>That network backend was also opening questions about other possible
improvements: for instance, using IIO devices from applications running on
different operating systems, like Windows, using those devices in environments
like <a class="reference external" href="https://wiki.analog.com/gnuradio">GNU Radio</a>, <a class="reference external" href="https://wiki.analog.com/libiio/clients/matlab_simulink">MATLAB</a>
or <a class="reference external" href="https://wiki.analog.com/libiio/clients/matlab_simulink">Simulink</a>, etc.</p>
</section>
</section>
<section id="license-and-code-management">
<h2>License and code management<a class="headerlink" href="#license-and-code-management" title="Link to this heading"></a></h2>
<p>Libiio has been developed and is released under the terms of the GNU Lesser
General Public License, version 2. This open-source license allows anyone to use
the library for proprietary or open-source, commercial or non-commercial
applications. This choice was motivated by the fact that Analog Devices is a
company that principally sells hardware, and this library provides the clients
with a better and easier way of using this hardware.</p>
<p>The full terms of the license can be found here:
<a class="reference external" href="http://opensource.org/licenses/LGPL-2.1">http://opensource.org/licenses/LGPL-2.1</a></p>
</section>
<section id="code-conformance">
<h2>Code conformance<a class="headerlink" href="#code-conformance" title="Link to this heading"></a></h2>
<p>A good part of libiio fully complies with the C99 and POSIX standards, and
should be compilable on any POSIX-compliant operating system supported by a C99
compiler. The exception is the local backend, which is Linux-specific and thus
can only be compiled for Linux systems. The library can also be compiled under
Visual Studio, which does not fully support C99 (in 2014…), by preferring ANSI
C89 when it makes sense. As the conformance to C99 and POSIX was a design
decision since the beginning of the project, porting the library to Windows has
been exceptionally easy and required very little change, thanks to the recent
POSIX sockets compatibility layer provided in Windows.</p>
</section>
<section id="code-visibility">
<h2>Code visibility<a class="headerlink" href="#code-visibility" title="Link to this heading"></a></h2>
<p>While the public API declares and references iio_context, iio_device,
iio_channel and iio_buffer objects, their content is never known to the client
application. All the public functions use pointers to opaque structures:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_context</span><span class="p">;</span>
<span class="n">__api</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">iio_context_destroy</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_context</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">);</span>
</pre></div>
</div>
<p>In this example, the content of the iio_context structure is never listed, but
the iio_context_destroy function accepts a pointer to an instance of that
structure as a parameter. This design choice has several benefits:</p>
<ul class="simple">
<li><p>The client applications are not able to modify directly the content of the
objects; they must use the public functions of the API instead. This prevents
the applications to mess with the internals of the library.</p></li>
<li><p>As the client applications manipulate only pointers, the structure of the
object can change from one version of the library to another without breaking
the ABI (binary interface). As a result, an old program compiled with an old
version of the library will run just fine with a new version of the library,
even if the structure of all the objects changed in the new version. This
brings a lot of flexibility, as a client software isn’t bound to one specific
version of the API.</p></li>
</ul>
<p>On top of that, the functions that compose the API of libiio are all prefixed
with “__api”. This token marks the corresponding functions as visible in the
library. The functions that are not marked are considered hidden and will not be
callable from outside the library. This ensures that client applications cannot
call internal functions, and use the API functions instead.</p>
</section>
<section id="backends">
<h2>Backends<a class="headerlink" href="#backends" title="Link to this heading"></a></h2>
<p>The libiio library has been designed from the start to support multiple
backends. The current 0.1 version features three different backends: a XML
backend, a local backend, a network backend. Concretely, a backend is
assimilated with a iio_context object. For each backend, one function in the
public API allows the creation of the corresponding iio_context object:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">__api</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_context</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iio_create_local_context</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">__api</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_context</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iio_create_xml_context</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">xml_file</span><span class="p">);</span>
<span class="n">__api</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_context</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iio_create_xml_context_mem</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">xml</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="n">__api</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_context</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iio_create_network_context</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">host</span><span class="p">);</span>
</pre></div>
</div>
<p>The iio_context object contains a pointer to a iio_backend_ops structure:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_backend_ops</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">words</span><span class="p">);</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This structure contains a set of function pointers that correspond to low-level
functionalities: read an attribute, open a device, stream data… Those
functions are specific to the backend used. For instance, the “read” function
pointer will be empty with the XML backend (as it does not support streaming
data), point to a function to retrieve a buffer full of freshly captured samples
from the Linux kernel with the local backend, or point to a function to send a
read request via the network with the network backend.</p>
<p>One thing to consider is that it is not a requirement to have all the backends
enabled for the library to work. For instance, the Windows versions are built
without the local backend, as this one is Linux-specific; and a build of the
library meant to run on a development board with IIO devices attached could be
compiled without the network and XML backends, as those would be unused.</p>
</section>
<section id="layering">
<h2>Layering<a class="headerlink" href="#layering" title="Link to this heading"></a></h2>
<p>The libiio library is built with two distinct layers. The top layer contains
the implementations of all the public functions. It is high-level, in the sense
that those functions can be used independently of the backend that was used to
create the iio_context object. Those functions only use the content of the
various objects of the context, and rely on the functions provided by the
backend in its “iio_backend_ops” structure to perform any low-level operation.
Those backend-specific functions form the bottom layer of the library.</p>
<p>Here is a short example, extracted from the source code of libiio, that shows
how the functions that compose the public API of the library can call the
backend-provided functions to perform operations:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="nf">iio_device_close</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">close</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOSYS</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The iio_device_close function is part of the public API. What it does, is just
call the “close” function provided by the backend if available. Of course, this
function’s implementation is very simple, but some other high-level functions
perform much more than just a call to a backend function.</p>
<p>The direct consequence of having proper code visibility and layering, is that
one application that use the libiio library and that was designed with the local
backend, will work remotely through the network just by changing one line of
code: create the iio_context object with iio_create_network_backend instead of
iio_create_local_backend. All the functions that the application will call will
have the exact same effect, but with a different behaviour.</p>
</section>
<section id="the-xml-and-local-backends">
<h2>The XML and local backends<a class="headerlink" href="#the-xml-and-local-backends" title="Link to this heading"></a></h2>
<section id="the-xml-backend">
<h3>The XML backend<a class="headerlink" href="#the-xml-backend" title="Link to this heading"></a></h3>
<p>One of the first things implemented in the library has been the XML backend.
Using this backend, it is possible to generate a libiio context from a
pre-existing XML file with a specific structure. This backend has been very
handy in the beginning of the development process, for the simple reason that it
simplifies the task of validating the code model: a XML file generated from the
code model with the iio_context_get_xml public function must be parsable, usable
by the XML backend, and result in the exact same objects being re-created.</p>
<p>The XML backend is the simplest backend. For instance, it does not provide any
low-level function to read or write attributes, or stream data. The full C code
of this backend fits in around 360 lines, so it is extremely small. It uses the
libxml2 library, available under Unix operating systems as well as Windows and
with a compatible license (LGPL) to validate then parse the XML file.</p>
<section id="document-type-definition">
<h4>Document Type Definition<a class="headerlink" href="#document-type-definition" title="Link to this heading"></a></h4>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;!DOCTYPE context [
    &lt;!ELEMENT context (device)*&gt;
    &lt;!ELEMENT device (channel | attribute | debug-attribute)*&gt;
    &lt;!ELEMENT channel (scan-element?, attribute*)&gt;
    &lt;!ELEMENT attribute EMPTY&gt;
    &lt;!ELEMENT scan-element EMPTY&gt;
    &lt;!ELEMENT debug-attribute EMPTY&gt;
    &lt;!ATTLIST context name CDATA #REQUIRED&gt;
    &lt;!ATTLIST device id CDATA #REQUIRED name CDATA #IMPLIED&gt;
    &lt;!ATTLIST channel id CDATA #REQUIRED type (input|output) #REQUIRED name CDATA #IMPLIED&gt;
    &lt;!ATTLIST scan-element index CDATA #REQUIRED format CDATA #REQUIRED scale CDATA #IMPLIED&gt;
    &lt;!ATTLIST attribute name CDATA #REQUIRED filename CDATA #IMPLIED&gt;
    &lt;!ATTLIST debug-attribute name CDATA #REQUIRED&gt;
]&gt;
</pre></div>
</div>
<p>This DTD corresponds to the format expected by the XML backend of the latest
libiio. It is always embedded at the top of the XML generated with
iio_context_get_xml, and the XML backend will verify that the given XML file
validates with the embedded format and issue an error if it’s not the case.</p>
<p>The format of the XML evolved quite a lot during the development phase of the
library, to reflect the new features implemented in the process. The
“scan-element” and “debug-attribute” elements, for instance, were added very
late in the development phase.</p>
</section>
</section>
<section id="the-local-backend">
<h3>The local backend<a class="headerlink" href="#the-local-backend" title="Link to this heading"></a></h3>
<p>The central and most complex piece of the libiio library is the local backend.
This may be the single most important part of the library, as it is the only
part that will actually interact with the hardware through the sysfs interface
of the Linux kernel.</p>
<section id="creation-of-the-context-from-sysfs">
<h4>Creation of the context from sysfs<a class="headerlink" href="#creation-of-the-context-from-sysfs" title="Link to this heading"></a></h4>
<p>The first task, when creating the local backend, has been to implement the
function iio_create_local_context, the one responsible for the creation of the
top-level iio_context object. The implementation of this functionality
represents maybe half of the complexity of the local backend. To understand why,
let’s have a look at how the generation of the objects from sysfs works.</p>
<p>Here is a list of files that can be found inside /sys/bus/iio/devices 1 :</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">:</span>    <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">name</span>
<span class="mi">2</span><span class="p">:</span>    <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">out_voltage0_V1_raw</span>
<span class="mi">3</span><span class="p">:</span>    <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">out_voltage0_V1_scale</span>
<span class="mi">4</span><span class="p">:</span>    <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">out_voltage0_V1_powerdown</span>
<span class="mi">5</span><span class="p">:</span>    <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">out_voltage0_V1_powerdown_mode</span>
<span class="mi">6</span><span class="p">:</span>    <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">out_voltage1_V2_raw</span>
<span class="mi">7</span><span class="p">:</span>    <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">out_voltage1_V2_scale</span>
<span class="mi">8</span><span class="p">:</span>    <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">out_voltage1_V2_powerdown</span>
<span class="mi">9</span><span class="p">:</span>    <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">out_voltage1_V2_powerdown_mode</span>
<span class="mi">10</span><span class="p">:</span>   <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">out_voltage_powerdown_mode_available</span>
<span class="mi">11</span><span class="p">:</span>   <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">sampling_rate</span>
<span class="mi">12</span><span class="p">:</span>   <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">scan_elements</span><span class="o">/</span><span class="n">in_voltage0_en</span>
<span class="mi">13</span><span class="p">:</span>   <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">scan_elements</span><span class="o">/</span><span class="n">in_voltage0_index</span>
<span class="mi">14</span><span class="p">:</span>   <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">scan_elements</span><span class="o">/</span><span class="n">in_voltage0_type</span>
<span class="mi">15</span><span class="p">:</span>   <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">scan_elements</span><span class="o">/</span><span class="n">in_voltage1_en</span>
<span class="mi">16</span><span class="p">:</span>   <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">scan_elements</span><span class="o">/</span><span class="n">in_voltage1_index</span>
<span class="mi">17</span><span class="p">:</span>   <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">scan_elements</span><span class="o">/</span><span class="n">in_voltage1_type</span>
</pre></div>
</div>
<p>The local backend will perform the following steps:</p>
<ul class="simple">
<li><p><strong>Identify the IIO devices that can be used</strong>. In this case, only one device
is present, so one single iio_device object will be created, with the ID
“iio:device0” and the name corresponding to the text contained in the “name”
attribute (line 1).</p></li>
<li><p><strong>Identify the various channels for each devices</strong>. In this example, the
device features four different channels: two output channels with the IDs
“voltage0” and “voltage1”, and two input channels with the IDs “voltage0” and
“voltage1”. Note that the IDs can be the same as long as their direction is
opposed, which is the case here. The correct way to identify a channel is by
looking at their ID and their direction.
The two output channels also have a name: “V1” and “V2”. Having a name is
optional, that’s why the two input channels don’t have any.
Note that the two input channels are located in a sub-directory called
“scan_elements”. All the files present in that directory correspond to
channels which support streaming (either capturing samples from the device
for input channels, or submitting samples to the device for output channels).</p></li>
<li><p><strong>Identify the channel-specific attributes</strong>. For instance, each one of the
two output channels will have the “raw”, “scale”, “powerdown” and
“powerdown_mode” attributes, most likely containing distinct values.</p></li>
<li><p><strong>Identify the attributes shared by all channels</strong>. In this example, the two
output channels will share one “powerdown_mode_available” attribute; if one
channel modifies the content of the attribute, it is modified for all the
channels of the device that have this attribute.</p></li>
<li><p><strong>Identify the device-specific attributes</strong>, so the ones that don’t apply to
channels at all. In this case, this device has one attribute named
“sample_rate”. In theory, it also has the “name” attribute, but this one is
not registered as an attribute in the iio_device object.</p></li>
</ul>
<p>Additionally, the local backend will also add “debug attributes” to any device
whose ID is found in the /sys/kernel/debug/iio directory. Those attributes can
be assimilated to device-specific attributes, their only specificity is that
they may not be available all the time. This directory being only browsable by
the “root” super-user, they may be found only if the application is started with
super-user rights.</p>
</section>
<section id="parsing-issues">
<h4>Parsing issues<a class="headerlink" href="#parsing-issues" title="Link to this heading"></a></h4>
<p>Although the kernel interface has been designed to be simple, it has not been
designed to be parsable. Let’s take an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="p">:</span>    <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">out_voltage0_V1_raw</span>
<span class="mi">2</span><span class="p">:</span>    <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">out_voltage0_V1_scale</span>
<span class="mi">3</span><span class="p">:</span>    <span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">out_voltage1_V2_raw</span>
</pre></div>
</div>
<p>The name of the “voltage0” channel is correctly detected as being “V1”, and the
two “raw” and “scale” attributes are detected properly. However, for the channel
“voltage1”, it is not possible to differentiate the channel name with the
attribute name: maybe the name is “V2” and the attribute name is “raw”, but
maybe the channel has no name and the attribute is named “V2_raw”…</p>
<p>The sad fact is that there is no easy way to address this issue; it has been
avoided so far, as channels often have more than one file in sysfs and rarely
have names. The issue is still present in the latest version of libiio, and will
probably be worked around by using a database to map the filenames in sysfs to
the corresponding device, channel and attribute.</p>
<p>The issue becomes even more complex if you consider that the filenames can
include “modifiers”. The modifiers are known tokens in filenames, the local
backend of the library uses a built-in list of modifiers to parse the filenames
better.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">sys</span><span class="o">/</span><span class="n">bus</span><span class="o">/</span><span class="n">iio</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">iio</span><span class="p">:</span><span class="n">device0</span><span class="o">/</span><span class="n">in_voltage_blue_sample_rate</span>
</pre></div>
</div>
<p>In that example, “blue” is a known modifier. “sample” could be the channel’s
name, or part of the attribute name. Note that the channel has no number, which
is a pointer that a modifier is used. If the word following “voltage” is not
recognized as a modifier, then the attribute is considered not to be a channel
attribute, but a device attribute.</p>
</section>
</section>
</section>
<section id="reading-and-writing">
<h2>Reading and writing<a class="headerlink" href="#reading-and-writing" title="Link to this heading"></a></h2>
<section id="enabling-channels">
<h3>Enabling channels<a class="headerlink" href="#enabling-channels" title="Link to this heading"></a></h3>
<p>The first thing to do to read or write samples to the hardware, is to enable
channels. This can be done using the public function iio_channel_enable:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">iio_channel_enable</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_channel</span><span class="w"> </span><span class="o">*</span><span class="n">chn</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">chn</span><span class="o">-&gt;</span><span class="n">is_scan_element</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">chn</span><span class="o">-&gt;</span><span class="n">index</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">chn</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">)</span>
<span class="w">        </span><span class="n">SET_BIT</span><span class="p">(</span><span class="n">chn</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="n">chn</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that this function does not perform any operation on the hardware, as it is
not a backend function. Instead, it marks the channel as enabled within its
parent iio_device structure. The real operation of enabling or disabling the
channels is performed by the backend, in its “open” function.</p>
</section>
<section id="creating-a-buffer">
<h3>Creating a buffer<a class="headerlink" href="#creating-a-buffer" title="Link to this heading"></a></h3>
<p>The second step, is to create a buffer bound to the device that will be used.
This can be done with the public function iio_device_create_buffer:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">__api</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_buffer</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iio_device_create_buffer</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">samples_count</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">cyclic</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>The “dev” parameter corresponds to the iio_device object that will be used.</p></li>
<li><p>The “samples_count” will set the size of the kernel’s internal buffer. The
value set should correspond to the amount of samples that will be asked in
each read or write operation.</p></li>
<li><p>The “cyclic” variable is used to inform the kernel whether or not the device
is to be opened in cyclic mode. In this configuration, the first buffer of
samples pushed to the hardware will be repeated continuously. This will be
explained later.</p></li>
</ul>
<p>Internally, the iio_device_create_buffer will call the backend’s “open”
function, defined with the following prototype:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_backend_ops</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">samples_count</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">words</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">cyclic</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The “dev”, “samples_count” and “cyclic” parameters are the same as above. The
“mask” and “words” parameters are new and shall be explained. The “mask”
variable points to an array of 32-bit words. The exact number of words it
contains is set in the “words” variable. Each 32-bit word of the array is a
bitmask: if the bit Y of the word X is set, then the channel number (32 * X +
Y) is enabled. Typically, a device doesn’t have more than a handful of channels,
so the “words” variable will almost always be set to 1. But the library must be
able to handle even devices with more than 32 channels. Those bits are set or
cleared with iio_channel_enable and iio_channel_disable, respectively; that’s
why it’s important to call those functions before creating a buffer.</p>
</section>
<section id="reading-and-writing-the-old-way">
<h3>Reading and writing, the old way<a class="headerlink" href="#reading-and-writing-the-old-way" title="Link to this heading"></a></h3>
<p>In the infancy of the libiio library, there was no iio_buffer class. Instead,
there were functions to open/close and read/write a device: iio_device_open,
iio_device_close, iio_device_read, etc. It worked fine for a start, but was also
severely limited, for several reasons:</p>
<ul class="simple">
<li><p>There is no guarantee that the channels that were marked as disabled in the
device’s channel mask can actually be disabled. As a matter of fact, the
stream that we read from the hardware can contain samples for channels that
we did not request, and when emitting data, the hardware may expect more
samples than what we’re sending.</p></li>
<li><p>The iio_device_read and iio_device_write copy the stream, between the
kernel’s internal buffer and userspace. That is fine for slow devices, not
for high-speed analog to digital converters that can produce 30 million
samples per second (240 MiB/s worth of data) on a board with a 400 MHz CPU
(like the ZedBoard).</p></li>
<li><p>Those read/write functions worked with the same sample format that the
hardware manipulates, so the samples had to be converted to a format that can
be processed after being copied from the kernel buffer, which resulted in an
enormous overhead.</p></li>
</ul>
</section>
<section id="reading-and-writing-with-the-iio-buffer-class">
<h3>Reading and writing with the iio_buffer class<a class="headerlink" href="#reading-and-writing-with-the-iio-buffer-class" title="Link to this heading"></a></h3>
<p>The iio_buffer object addresses all those issues by providing a smarter API, and
encapsulating a part of the complexity. The iio_buffer object offers several
possible methods to read or write samples:</p>
<ul>
<li><p>If you just want to dump the content of the internal buffer, you can just use
the functions iio_buffer_start and iio_buffer_end to get the start and end
addresses of the buffer, and then use the standard memcpy function to dump a
part or the totality of the buffer.</p></li>
<li><p>Use iio_buffer_first, iio_buffer_step and iio_buffer_end to iterate over the
samples of one given channel contained inside the internal buffer:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iio_buffer_first</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">channel</span><span class="p">);</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">iio_buffer_end</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">iio_buffer_step</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* ptr points to one sample of the channel we&#39;re interested in */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This method can be very useful if the data of a channel has to be processed
sample by sample, as in this case, there is no copy to an intermediate
buffer. As the inner loops gets a pointer to the sample’s emplacement, it can
be used either to read or write the buffer.</p>
</li>
<li><p>Alternatively, the iio_buffer class contains a method called
iio_buffer_foreach_sample. This function takes a function pointer as
argument: the supplied callback will be called for each sample of the buffer.
The callback receives four arguments: a pointer to the iio_channel structure
corresponding to the sample, a pointer to the sample itself, the length of
the sample in bytes, plus a pointer optionally set as argument of
iio_buffer_foreach_sample. Again, this function can be used to read from or
write to the buffer.
The main difference with the previous method, is that the callback is called
for each sample of the buffer, in the order that they appear in the buffer,
and not ordered by channels. As said previously, the buffer can contain
samples of channels that we didn’t request; the callback can just check
whether or not the sample’s channel is enabled with iio_channel_is_enabled,
and just return zero if it’s not.</p></li>
<li><p>The last method is to use one of the higher-level functions provided by the
iio_channel class: iio_channel_read_raw, iio_channel_write_raw,
iio_channel_read, iio_channel_write. The former two will basically copy the
first N samples of one channel to/from a user-specified buffer (N depending
of the size of this one buffer). Note that this function can be replaced with
the first method and a memcpy (that’s what it does internally, after all).
The latter two will do the same, but will additionally convert all the
samples copied from the raw format to the format that can be used by the
applications.</p></li>
</ul>
</section>
<section id="refilling-and-submitting-a-buffer">
<h3>Refilling and submitting a buffer<a class="headerlink" href="#refilling-and-submitting-a-buffer" title="Link to this heading"></a></h3>
<p>It has to be noted that all the methods announced above will only work on the
samples contained within the internal buffer of the iio_buffer class. In fact,
two successive calls to iio_buffer_foreach_sample for instance will iterate over
the very same samples twice. To obtain fresh samples from the hardware, it is
required to call the function iio_device_refill. Needless to say that the
previous content of the buffer is overwritten. On the other hand, to submit
samples that were written inside the iio_buffer, it is possible to call the
function iio_buffer_push. Those two functions will call either the backend’s
“read” or “write” functions, or if available, its “get_buffer” function (used in
the local backend as a high-speed interface. We’ll see about that later).</p>
</section>
<section id="format-conversion">
<h3>Format conversion<a class="headerlink" href="#format-conversion" title="Link to this heading"></a></h3>
<p>As stated previously, the <strong>iio_channel_read</strong> and <strong>iio_channel_write</strong>
functions convert the samples from/to their hardware format to/from the format
of the architecture on which libiio is running. They actually simply call the
iio_channel_convert and iio_channel_convert_inverse public API functions. These
two deserve some explanations.</p>
<p>First, here is a textual representation of the hardware format as reported by
the kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">&gt;</span><span class="c1"># cat /sys/bus/iio/devices/iio:device0/scan_elements/in_voltage0_type</span>
<span class="n">le</span><span class="p">:</span><span class="n">s12</span><span class="o">/</span><span class="mi">16</span><span class="o">&gt;&gt;</span><span class="mi">4</span>
</pre></div>
</div>
<p>What it says, is that the hardware samples are in little-endian order (“le”),
that the sample size is 16 bits, but with only 12 bits worth of data. The “&gt;&gt;4”
shift informs that those 12 bits are located after 4 most-significant bits
(MSB), so in this particular case they correspond to the 12 less-significant
bits (LSB), as 16 – 4 = 12. The “s” character of “s12” means that the 12-bit
value is signed.</p>
<p>From this hardware representation, the conversion functions will process the
samples so that they become 16-bit unsigned values.</p>
<p>The conversion process may look like an easy task; however, the implementation
is rather complex, for a good reason: it has been designed to handle samples of
any possible size. It makes it possible to process 256-bit samples on a 32-bit
CPU, for instance, while compilers typically don’t handle numbers that large.</p>
</section>
<section id="low-speed-interface">
<h3>Low-speed interface<a class="headerlink" href="#low-speed-interface" title="Link to this heading"></a></h3>
<p>The low-speed interface of the local backend was the first one to be
implemented. It is also the simplest. It is composed by the four following
backend functions:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_backend_ops</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">samples_count</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">words</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">cyclic</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">mask</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">words</span><span class="p">);</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The prototype of the “open” function has been explained previously. In the local
backend, when the low-speed interface is used, it will perform the following
operations:</p>
<ul class="simple">
<li><p>disable the internal kernel buffer (if it was enabled previously),</p></li>
<li><p>set the size of the kernel buffer, by writing the number of samples (given by
“samples_count”) inside the “buffer/size” attribute of the device (which
corresponds to the file “/sys/bus/iio/devices/iio_deviceX/buffer/size”),</p></li>
<li><p>open the “/dev/iio:deviceX” file for reading and writing,</p></li>
<li><p>and finally, enable the channels which should be used by writing their “en”
file (e.g. “/sys/bus/iio/devices/iio_deviceX/scan_elements/in_voltage0_en”).</p></li>
</ul>
<p>Then, the “read” and “write” backend functions will respectively read and write
the “/dev/iio:deviceX” node. The stream manipulated contains samples in their
raw format. Those two functions are used from within the iio_buffer class, when
the application requests the buffer to be refilled with iio_buffer_refill or
wants to submit a buffer full of data with iio_buffer_push. The data flow
occuring with the low-speed interface can be explained with the following
schema:</p>
<a class="reference internal image-reference" href="../../_images/libiio_lowspeed_interface.png"><img alt="../../_images/libiio_lowspeed_interface.png" src="../../_images/libiio_lowspeed_interface.png" style="width: 600px;" />
</a>
<p>When receiving from an input device (red arrows), the kernel will fill its
internal buffer with new samples, directly from the hardware using DMA transfers
if the hardware supports it, or by reading hardware registers (low-speed devices
are generally connected with I2C or SPI). When an application calls
iio_buffer_refill, the samples contained in the kernel’s buffer will be copied
to the iio_buffer’s internal buffer, where they can be manipulated.</p>
<p>When streaming to an output device (blue arrows), the application will fill the
iio_buffer’s internal buffer with samples then call iio_buffer_push, which will
copy those new samples into the kernel’s buffer. Then, the kernel will transfer
them to the hardware.</p>
<p>So what exactly makes it a low-speed interface? Between the kernel buffer and
the iio_buffer object, the samples are copied. On slow devices, it doesn’t
matter much. But on devices that can function at very high frequencies, the
overhead caused by the copying process is enormous. As libiio is meant to be
fast even on slow CPUs, a different approach was necessary.</p>
</section>
<section id="high-speed-mmap-interface">
<h3>High-speed mmap interface<a class="headerlink" href="#high-speed-mmap-interface" title="Link to this heading"></a></h3>
<p>The high-speed interface is only implemented by the local backend, while the
low-speed interface is also supported by the network backend. It requires a very
recent Linux kernel, and even with that it is not supported by all kernel
drivers. In the difference of the low-speed interface, it is not implemented
with the “read” or “write” backend functions, but with a function named
“get_buffer”; as such, one backend can provide both interfaces. This is the case
for the local backend, for instance.</p>
<p>The “get_buffer”, as its name implies, retrieves a buffer from kernel space, or
more specifically a pointer to a buffer allocated in kernel space. The main
difference of this interface, is that the kernel manipulates not only one
buffer, but a multitude of buffers. In the local backend, for instance, it
manipulates four buffers. For input channels, the “get_buffer” function will
atomically query the kernel for a new buffer with fresh samples, and push the
old buffer back on the kernel’s buffer queue. For output channels, the principle
stays the same, but the “get_buffer” function will atomically query an empty
buffer that the application can fill, and push the previous buffer that has been
written to.</p>
<p>Better than a wall of text, this schema sums up the principle of the high-speed
interface:</p>
<a class="reference internal image-reference" href="../../_images/libiio_highspeed_interface.png"><img alt="../../_images/libiio_highspeed_interface.png" src="../../_images/libiio_highspeed_interface.png" style="width: 500px;" />
</a>
<p>Note that this schema represents a capture process. For an output process, just
consider all the arrows inverted.</p>
<p>Here is the prototype of the “get_buffer” backend function:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_backend_ops</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">get_buffer</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iio_device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">addr_ptr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">bytes_used</span><span class="p">);</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>As expected, the “dev” parameter corresponds to the iio_device object that
will be used.</p></li>
<li><p>The “addr_ptr” is a pointer to the address of a buffer. The buffer pointed by
“addr_ptr” will be enqueued to the kernel’s queue, and “addr_pointer” will be
changed to point to a new buffer. Note that the interface makes no difference
between input and output devices, as in both cases a buffer is enqueued and a
new one is dequeued.</p></li>
</ul>
<p>Of course, it’s always preferable to use the high-speed interface, when the
driver allows it. Internally, the iio_buffer object will first try to use the
high-speed interface, and if it’s detected as not available, it will switch back
to the old interface.</p>
</section>
<section id="cyclic-buffers">
<h3>Cyclic buffers<a class="headerlink" href="#cyclic-buffers" title="Link to this heading"></a></h3>
<p>As stated previously, the iio_buffer class allows the creation of cyclic
buffers, by setting the “cyclic” parameter of the function
iio_device_create_buffer to True. In this case, the very first buffer pushed
(either with the slow interface or the newer high-speed interface) will be
repeated until the buffer is destroyed with iio_buffer_destroy. Once the first
buffer has been pushed, any subsequent call to the function iio_buffer_push will
issue an error and return a negative error code. This feature can be used to
output a specific waveform, for instance.</p>
<p>Note that cyclic buffers only make sense for output devices. The “cyclic”
parameter of the iio_device_create_buffer function will simply be ignored when
the related device is a capture device.</p>
</section>
</section>
<section id="the-network-backend-and-iio-daemon">
<h2>The network backend and IIO Daemon<a class="headerlink" href="#the-network-backend-and-iio-daemon" title="Link to this heading"></a></h2>
<section id="conception-of-the-iio-daemon">
<h3>Conception of the IIO Daemon<a class="headerlink" href="#conception-of-the-iio-daemon" title="Link to this heading"></a></h3>
<section id="why-a-network-backend">
<h4>Why a network backend?<a class="headerlink" href="#why-a-network-backend" title="Link to this heading"></a></h4>
<p>Before libiio even existed, it was already decided that the library had to have
a network backend, and this for several reasons:</p>
<ul class="simple">
<li><p>The first reason is obviously to allow the applications using libiio to
stream samples on the network to any connected device. This has some
benefits, notably for debugging purposes, and it makes development easier as
there is no need to cross-compile the libiio-powered applications anymore.</p></li>
<li><p>Previously, the applications developed at Analog Devices that were using the
IIO subsystem were for the most part meant to run directly on the target
boards, that are generally equipped with weak CPUs in comparison to regular
workstations. While those target do the job when it comes to transferring
samples, they are not suitable for processing them, especially at a high
speed. It may appear counter-intuitive, but streaming the samples via the
network to a more powerful workstation allows to use a much higher sample
rate without having samples lost.</p></li>
<li><p>Even when used locally, via the “lo” virtual network interface, a network
backend makes sense. While the use of the local backend would result in a
higher throughput and less resource usage, the IIO interface of the Linux
kernel does not allow for more than one process or thread to access the same
device at the same moment. By connecting two clients to the IIO daemon, which
serves the requests from the network, it is possible for both of them to
receive a copy of the stream of samples. This becomes extremely interesting,
as it is now possible for instance to monitor the input stream received by a
given application with the IIO Oscillator software (or any other suitable
tool).</p></li>
<li><p>Finally, the network backend brings security. For advanced features, the
applications using libiio with its local backend require super-user rights,
which may not be suitable. When the network backend is used, the same
features are available without super-user rights: the applications connect to
and dialog with the IIO daemon, which possesses the super-user rights and
properly exposes the advanced features to its clients.</p></li>
</ul>
</section>
<section id="challenges">
<h4>Challenges<a class="headerlink" href="#challenges" title="Link to this heading"></a></h4>
<p>Developing the IIO Daemon (IIOD) has been the most challenging part of the
project; most of the complexity of the library is concentrated in this program.
To understand why, let’s see a short list of the various characteristics of
IIOD:</p>
<ul class="simple">
<li><p>It is a network daemon. As such, it has to handle and manage incoming
connections. Doing a network daemon properly means handling several clients
in parallel, handling client disconnections without crashing, leaking memory
or in more general terms leaving the daemon in a bad state. It also has to
survive a network failure, disconnect unresponsive clients after a given
timeout, etc.</p></li>
<li><p>To each connected client corresponds a thread in the server, that will
interpret the commands sent and answer accordingly. All those different
threads will execute the very same panel of functions. This means that all
those functions must be thread-safe, that is to say safe to use in a
multi-thread context: accesses to global resources are protected using
locking mechanisms, and avoided as much as possible, in favor of a per-thread
context structure. Furthermore, to each opened device correspond one other
thread, called in this document the read-write (R/W) thread. For instance,
with 4 connected clients opening a different device each, the IIOD has 1+4*2
= 9 threads running in parallel: one main thread, one client thread per
application connected and one R/W thread per device opened.</p></li>
<li><p>It handles multiples clients using the same device at the same time. Each
client receives a stream of samples corresponding to the channels requested;
the daemon is in charge of duplicating the stream to the connected clients.</p></li>
</ul>
</section>
<section id="far-distance-view">
<h4>Far-distance view<a class="headerlink" href="#far-distance-view" title="Link to this heading"></a></h4>
<a class="reference internal image-reference" href="../../_images/libiio_farview.png"><img alt="../../_images/libiio_farview.png" src="../../_images/libiio_farview.png" style="width: 350px;" />
</a>
<p>One interesting characteristic of IIOD is that it actually uses libiio
underneath. In a way, it is at the same time a client application for the libiio
library, as well as a component used by the library. Each command of the
interpreter of IIOD is backed by the corresponding API function of libiio; and
in the network backend, to each backend function corresponds one command within
the IIOD server. IIOD has been designed that way to avoid code duplication as
much as possible, and to test the validity and the robustness of the high-level
API of libiio.</p>
</section>
</section>
<section id="the-command-interpreter">
<h3>The command interpreter<a class="headerlink" href="#the-command-interpreter" title="Link to this heading"></a></h3>
<section id="flex-bison">
<h4>Flex, Bison<a class="headerlink" href="#flex-bison" title="Link to this heading"></a></h4>
<p>The command interpreter has been written using the popular GNU tools Flex and
Bison, free and open-source variants of the old Lex and Yacc tools. Those
programs can be used to generate a lexer and a parser from source files defining
the commands and the behaviour of the interpreter. The output consists in C
files, that can then be compiled or cross-compiled along with the rest of the
source code of the IIOD server.</p>
<p>Using Flex and Bison ensured that the code base would stay small, smart and
concise. Writing an interpreter from zero in pure C can be a difficult task, and
often (if not always) transform in a big code bloat with plenty of space for
bugs to hide. This is true especially in this case, where the interpreter is
meant to be ran across multiple threads.</p>
</section>
<section id="protocol">
<h4>Protocol<a class="headerlink" href="#protocol" title="Link to this heading"></a></h4>
<p>In the version 0.1 of the IIOD server, the following commands are accepted:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">HELP</span>
    <span class="n">Print</span> <span class="n">this</span> <span class="n">help</span> <span class="n">message</span>
<span class="n">EXIT</span>
    <span class="n">Close</span> <span class="n">the</span> <span class="n">current</span> <span class="n">session</span>
<span class="n">PRINT</span>
    <span class="n">Display</span> <span class="n">a</span> <span class="n">XML</span> <span class="n">string</span> <span class="n">corresponding</span> <span class="n">to</span> <span class="n">the</span> <span class="n">current</span> <span class="n">IIO</span> <span class="n">context</span>
<span class="n">VERSION</span>
    <span class="n">Get</span> <span class="n">the</span> <span class="n">version</span> <span class="n">of</span> <span class="n">libiio</span> <span class="ow">in</span> <span class="n">use</span>
<span class="n">TIMEOUT</span> <span class="o">&lt;</span><span class="n">timeout_ms</span><span class="o">&gt;</span>
    <span class="n">Set</span> <span class="n">the</span> <span class="n">timeout</span> <span class="p">(</span><span class="ow">in</span> <span class="n">ms</span><span class="p">)</span> <span class="k">for</span> <span class="n">I</span><span class="o">/</span><span class="n">O</span> <span class="n">operations</span>
<span class="n">OPEN</span> <span class="o">&lt;</span><span class="n">device</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">samples_count</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">CYCLIC</span><span class="p">]</span>
    <span class="n">Open</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">device</span> <span class="k">with</span> <span class="n">the</span> <span class="n">given</span> <span class="n">mask</span> <span class="n">of</span> <span class="n">channels</span>
<span class="n">CLOSE</span> <span class="o">&lt;</span><span class="n">device</span><span class="o">&gt;</span>
    <span class="n">Close</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">device</span>
<span class="n">READ</span> <span class="o">&lt;</span><span class="n">device</span><span class="o">&gt;</span> <span class="n">DEBUG</span><span class="o">|</span><span class="p">[</span><span class="n">INPUT</span><span class="o">|</span><span class="n">OUTPUT</span> <span class="o">&lt;</span><span class="n">channel</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">attribute</span><span class="o">&gt;</span><span class="p">]</span>
    <span class="n">Read</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">an</span> <span class="n">attribute</span>
<span class="n">WRITE</span> <span class="o">&lt;</span><span class="n">device</span><span class="o">&gt;</span> <span class="n">DEBUG</span><span class="o">|</span><span class="p">[</span><span class="n">INPUT</span><span class="o">|</span><span class="n">OUTPUT</span> <span class="o">&lt;</span><span class="n">channel</span><span class="o">&gt;</span><span class="p">]</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">attribute</span><span class="o">&gt;</span><span class="p">]</span> <span class="o">&lt;</span><span class="n">bytes_count</span><span class="o">&gt;</span>
    <span class="n">Set</span> <span class="n">the</span> <span class="n">value</span> <span class="n">of</span> <span class="n">an</span> <span class="n">attribute</span>
<span class="n">READBUF</span> <span class="o">&lt;</span><span class="n">device</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">bytes_count</span><span class="o">&gt;</span>
    <span class="n">Read</span> <span class="n">raw</span> <span class="n">data</span> <span class="kn">from</span><span class="w"> </span><span class="nn">the</span> <span class="n">specified</span> <span class="n">device</span>
<span class="n">WRITEBUF</span> <span class="o">&lt;</span><span class="n">device</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">bytes_count</span><span class="o">&gt;</span>
    <span class="n">Write</span> <span class="n">raw</span> <span class="n">data</span> <span class="n">to</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">device</span>
<span class="n">GETTRIG</span> <span class="o">&lt;</span><span class="n">device</span><span class="o">&gt;</span>
    <span class="n">Get</span> <span class="n">the</span> <span class="n">name</span> <span class="n">of</span> <span class="n">the</span> <span class="n">trigger</span> <span class="n">used</span> <span class="n">by</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">device</span>
<span class="n">SETTRIG</span> <span class="o">&lt;</span><span class="n">device</span><span class="o">&gt;</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">trigger</span><span class="o">&gt;</span><span class="p">]</span>
    <span class="n">Set</span> <span class="n">the</span> <span class="n">trigger</span> <span class="n">to</span> <span class="n">use</span> <span class="k">for</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">device</span>
<span class="n">SET</span> <span class="o">&lt;</span><span class="n">device</span><span class="o">&gt;</span> <span class="n">BUFFERS_COUNT</span> <span class="o">&lt;</span><span class="n">count</span><span class="o">&gt;</span>
    <span class="n">Set</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">kernel</span> <span class="n">buffers</span> <span class="k">for</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">device</span>
</pre></div>
</div>
<p>When started normally (not in debug mode), the IIOD will answer those commands
by a numeric code sent in plain text. This code corresponds to -22 (the value of
-EINVAL) if the parser did not understand the command. If the command has been
properly parsed, the server will forward the value returned by the underlying
libiio function, like iio_device_close for the CLOSE command.</p>
<p>For some operations, in case the return code is strictly positive, the server
will also send a number of bytes of data defined by the value of the return
code. This is the case for instance for the PRINT, READ and READBUF commands.</p>
<p>On the other hand, the WRITE and WRITEBUF operations will require a certain
number of bytes to follow the command call; For those operations, this number
must be specified as the “bytes_count” parameter in the command. The client’s
thread will then ignore the given amount of bytes and just route them to the
underlying libiio function. Once all the bytes have been transferred, the
interpreter resumes its normal process.</p>
</section>
</section>
<section id="sending-and-receiving-samples">
<h3>Sending and receiving samples<a class="headerlink" href="#sending-and-receiving-samples" title="Link to this heading"></a></h3>
<section id="opening-a-device">
<h4>Opening a device<a class="headerlink" href="#opening-a-device" title="Link to this heading"></a></h4>
<p>Opening a device from the network can be performed with the OPEN command.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OPEN</span> <span class="o">&lt;</span><span class="n">device</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">samples_count</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">mask</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">CYCLIC</span><span class="p">]</span>
</pre></div>
</div>
<p>The client thread of IIOD that corresponds to the connected client will then
register itself as a potential customer for capturing or uploading samples.</p>
<ul class="simple">
<li><p>If the client application is the first to open the given device, a new thread
will be started: the read-write (R/W) thread. Its purpose is to monitor the
list of registered clients for R/W requests, read or write the device, and if
reading upload the captured data to all the clients requesting samples.</p></li>
<li><p>If the application requests reading and another application is also using the
same device for reading, it means that the R/W thread is already started. In
this case, the client thread of IIOD will register itself aside of the other
application, and the R/W thread will upload the captured data to both.</p></li>
<li><p>If the application requests writing, but another application is already using
the same device, an error code is returned. In theory, it should be possible
to handle different clients writing to one single device if they are writing
to different channels; but that has not been implemented yet.</p></li>
</ul>
<p>As the local backend only allows one device to be opened by one process at a
time, the R/W thread is responsible for holding the iio_buffer object. When
started, due to one client using the OPEN command, it will call
iio_device_create_buffer. If all the clients disconnected or used the CLOSE
command, the R/W thread will stop itself after destroying the buffer with
iio_buffer_destroy.</p>
<p>It is important to note that the iio_buffer object is also destroyed and
recreated each time a new client use the OPEN command. This is done for two
reasons:</p>
<ul class="simple">
<li><p>The number of samples requested to libiio must correspond to the highest
number requested by the connected clients. This ensures that the buffer used
within the IIO subsystem of the Linux kernel is of the right size, so that no
samples will be dropped.</p></li>
<li><p>The channel mask requested to libiio must include all the channels requested
by the various clients. For instance, if one application sends the OPEN
command to use the channel 1, and a separate application sends this command
to use the channel 2, then the R/W thread will re-create the iio_buffer
object with a channel mask corresponding to the two channels being enabled.
This is done to ensure that each client application will receive samples for
each channel it requested.</p></li>
</ul>
<a class="reference internal image-reference" href="../../_images/libiio_open_command.png"><img alt="../../_images/libiio_open_command.png" src="../../_images/libiio_open_command.png" style="width: 700px;" />
</a>
</section>
<section id="the-read-write-thread">
<h4>The read/write thread<a class="headerlink" href="#the-read-write-thread" title="Link to this heading"></a></h4>
<p>When an application is ready to capture or emit samples, it will send the
READBUF or WRITEBUF command (respectively) to the IIOD server, with the number
of bytes to read or write as parameter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">READBUF</span> <span class="o">&lt;</span><span class="n">device</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">bytes_count</span><span class="o">&gt;</span>
<span class="n">WRITEBUF</span> <span class="o">&lt;</span><span class="n">device</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">bytes_count</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The corresponding client thread will then mark itself as requesting samples to
be transferred, and then sleep while waiting for a signal from the R/W thread.</p>
<p>Periodically, the R/W thread will go through its list of registered clients. If
the R/W thread corresponds to an output device, then only one client can
register at a time; when this client requests samples to be written to the
device, the R/W thread will copy the stream of samples inside the iio_buffer
object, and then use iio_buffer_push to submit the data to the hardware.</p>
<p>If one or more clients are requesting to read samples, the thread will call the
libiio API function iio_buffer_refill to fetch a set of fresh samples, and then
upload them to each client.</p>
<a class="reference internal image-reference" href="../../_images/libiio_readbuf_command.png"><img alt="../../_images/libiio_readbuf_command.png" src="../../_images/libiio_readbuf_command.png" style="width: 700px;" />
</a>
<p>As soon as the amount of bytes requested by one client thread has been
transferred, it will be awaken by the R/W thread, and will be passed a return
code.</p>
</section>
<section id="data-transfer">
<h4>Data transfer<a class="headerlink" href="#data-transfer" title="Link to this heading"></a></h4>
<p>When one client is registered for writing, it will send the sample data right
after the WRITEBUF command. The number of bytes uploaded to the server must
correspond to the number specified in the WRITEBUF command. When receiving the
data, the R/W thread will simply copy it into the internal buffer of the
iio_buffer object then call iio_buffer_push, until all the data has been
submitted to the hardware.</p>
<p>When one client is registered for reading, as explained previously, the R/W
thread will first send a return code. This value represents an error code if
negative, or the amount of bytes that will be transferred if positive or zero.
Right after this value, if no error occurred, the channel mask will be appended,
followed by the data. If the number of bytes specified in the READBUF command is
superior to the size of the buffer, then the data is uploaded in separate
chunks, each chunk containing one return code followed by a number of bytes
inferior or equal to the buffer size. This makes sense, considering that the R/W
thread can only refill one buffer worth of data, so it cannot assume that more
than one buffer of samples will be available.</p>
<a class="reference internal image-reference" href="../../_images/libiio_details_readbuf.png"><img alt="../../_images/libiio_details_readbuf.png" src="../../_images/libiio_details_readbuf.png" style="width: 600px;" />
</a>
<p>A return code of zero is actually not an error code. It is used to notify the
client application that no more samples can be read in this READBUF command, and
that a new READBUF command should be used. This happens for instance when a new
client registered, and the channel mask was modified.</p>
</section>
<section id="server-side-and-client-side-de-multiplexing">
<h4>Server-side and client-side de-multiplexing<a class="headerlink" href="#server-side-and-client-side-de-multiplexing" title="Link to this heading"></a></h4>
<p>When only one client is registered for reading, the process of uploading is
rather easy. The R/W thread will just write the content of the iio_buffer’s
internal buffer to the socket of the client. But this is different when multiple
clients are registered for the same device, and try to access separate channels;
in this case, it is required to de-multiplex the samples.</p>
<p>The process of de-multiplexing consists in extracting the samples corresponding
to a given channel set, from a stream that contains samples for more channels.
In libiio and IIOD, it exists in two different forms:</p>
<ul class="simple">
<li><p>Server-side de-multiplexing means that the algorithm is executed within the
server itself. When uploading the captured data back to the client
application, the R/W thread will only upload the samples that belong to
channels that were enabled by the application. This has several advantages:
the client receives only the samples it requested, and the network link usage
is kept relatively low.</p></li>
<li><p>Client-side de-multiplexing means that the algorithm is executed by the
client application. On that case, the IIOD server will upload the same buffer
to all the clients who requested samples. This has a big negative impact on
network usage, as the clients also receive samples of channels that weren’t
requested. Additionally, the applications have to handle the fact that they
may obtain less worthy samples than the number they requested.
On the plus side, client-side de-multiplexing puts all the burden of the
process to the clients, which results in a big win when looking at resource
usage of the target board. This is especially true on relatively slow
processors, which then become capable of streaming at a much higher
throughput without losing samples (around ten times the speed on a 400 MHz
board).
Furthermore, de-multiplexing is a very easy process for the application,
thanks to the iio_buffer functions: iio_buffer_foreach_sample and the combo
of iio_buffer_first / iio_buffer_step / iio_buffer_end will simply ignore the
samples corresponding to channels that the application didn’t enable.
Provided that the application use one of those methods to read the samples
(iio_channel_read / iio_channel_read_raw will work as well), and doesn’t
expect to receive the exact number of samples it requested, then it already
supports both server-side and client-side de-multiplexing.</p></li>
</ul>
</section>
</section>
<section id="the-network-backend">
<h3>The network backend<a class="headerlink" href="#the-network-backend" title="Link to this heading"></a></h3>
<section id="sending-and-receiving-commands">
<h4>Sending and receiving commands<a class="headerlink" href="#sending-and-receiving-commands" title="Link to this heading"></a></h4>
<p>In comparison with the complexity of the IIOD server, the network backend of the
library is extremely simple. Each call to one of its backend function will
result in a command being sent to the IIOD server. The “open” backend function
will send the OPEN command, the “read” function will send READBUF, etc. The
parameters passed to the backend functions are properly converted to ASCII
according to the schema that the IIOD understands. The code returned by the
server will be used as the return value of the backend function.</p>
<a class="reference internal image-reference" href="../../_images/libiio_commands.png"><img alt="../../_images/libiio_commands.png" src="../../_images/libiio_commands.png" style="width: 500px;" />
</a>
<p>Considering that the IIOD also uses the public API of libiio, the network
backend is completely transparent: the backend functions behave just like their
local backend counterpart. In theory, it would be completely possible to make
IIOD use the network backend, and chain two IIOD servers together!</p>
</section>
<section id="context-creation">
<h4>Context creation<a class="headerlink" href="#context-creation" title="Link to this heading"></a></h4>
<p>One interesting note about the network backend, is how it creates its context.
Once the application calls the API function iio_create_network_context, and the
network link is established with the IIOD server, the initialization function of
the network backend sends the PRINT command to the server. For the record, this
command returns an XML string which represents the structure of the whole IIO
context as seen by the server. From that XML string, the network backend will
actually create a IIO context from the XML backend, using the public API
function iio_context_create_xml_mem. Then, it will just piggy-back its own set
of backend functions to replace the ones provided by the XML backend.</p>
</section>
<section id="zero-configuration">
<h4>Zero-configuration<a class="headerlink" href="#zero-configuration" title="Link to this heading"></a></h4>
<p>One late feature implemented in the network backend of libiio and in the IIOD
server has been the support of auto-configuration. If a NULL pointer is passed
as the “hostname” argument of iio_create_network_context, then the network
backend will attempt to discover and establish a connection to a IIOD server
present on the network.</p>
<p>This feature depends on the Avahi zero-configuration software stack. It can be
enabled by setting the preprocessor flag HAVE_AVAHI to a non-zero value; the
IIOD will then register itself to the Avahi daemon if one is running on the
target, and the network backend will query the local Avahi server for a IIOD
server to use.</p>
</section>
</section>
</section>
<section id="libiio-now-and-in-the-future">
<h2>Libiio, now and in the future<a class="headerlink" href="#libiio-now-and-in-the-future" title="Link to this heading"></a></h2>
<section id="bindings">
<h3>Bindings<a class="headerlink" href="#bindings" title="Link to this heading"></a></h3>
<p>C is a good language, but not everybody is familiar with it; some people might
prefer object-oriented languages, like Java or Python for instance. This is why
we created bindings for the library, so that it can be used with different
programming languages. The additional languages supported by libiio are now
Python and C#.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Since v0.19 all bindings require explicit flags to be enabled
during builds. Please reference the <a class="icon git reference external" href="https://github.com/analogdevicesinc/libiio/tree/main/README_BUILD.md">build instructions</a>
to make sure the desired bindings are built and installed.</p>
</div>
<section id="python-bindings">
<h4>Python bindings<a class="headerlink" href="#python-bindings" title="Link to this heading"></a></h4>
<p>The Python bindings were developed very early in the project to facilitate
generating XML strings modeling IIO contexts in order to properly test the XML
backend. They quickly became outdated as the project moved on, but were later
greatly improved and should now be on par with the C# bindings.</p>
<p>To create the bindings, The “ctypes” module has been used:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">ctypes</span><span class="w"> </span><span class="kn">import</span> <span class="n">POINTER</span><span class="p">,</span> <span class="n">Structure</span><span class="p">,</span> <span class="n">cdll</span><span class="p">,</span> <span class="n">c_char_p</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_init</span><span class="p">():</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">_Device</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="n">DevicePtr</span> <span class="o">=</span> <span class="n">POINTER</span><span class="p">(</span><span class="n">_Device</span><span class="p">)</span>

    <span class="n">lib</span> <span class="o">=</span> <span class="n">cdll</span><span class="o">.</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="s1">&#39;libiio.so.0&#39;</span><span class="p">)</span>

    <span class="k">global</span> <span class="n">_d_get_id</span>
    <span class="n">_d_get_id</span> <span class="o">=</span> <span class="n">lib</span><span class="o">.</span><span class="n">iio_device_get_id</span>
    <span class="n">_d_get_id</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">c_char_p</span>
    <span class="n">_d_get_id</span><span class="o">.</span><span class="n">archtypes</span> <span class="o">=</span> <span class="p">(</span><span class="n">DevicePtr</span><span class="p">,</span> <span class="p">)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Device</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_device</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_device</span> <span class="o">=</span> <span class="n">_device</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">_d_get_id</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_device</span><span class="p">)</span>
</pre></div>
</div>
<p>This code shows the _init function, whose goal here is to load the library and
create wrappers in Python for the C functions of libiio. Objects created from
the Device class provide a couple of methods that will call those wrappers. Some
of the known constant values of the IIO objects, like the ID of a device, are
cached within the Python classes for faster access. Then, printing the ID of a
device in a Python script is as easy as typing “print my_device.id”. To better
understand the available calls consult the
<a class="icon git reference external" href="https://github.com/analogdevicesinc/libiio/tree/main/bindings/python/iio.py">bindings source</a> and some available
<a class="reference external" href="https://github.com/analogdevicesinc/plutosdr_scripts">examples</a>.</p>
<section id="installation">
<h5>Installation<a class="headerlink" href="#installation" title="Link to this heading"></a></h5>
<p>Since v0.21 the python bindings have been available through pypi, and therefore
can be installed with pip:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">pylibiio</span>
</pre></div>
</div>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Note that this will just install the bindings and will error if
the library itself is not installed.</p>
</div>
</section>
<section id="pyadi-iio">
<h5>PyADI-IIO<a class="headerlink" href="#pyadi-iio" title="Link to this heading"></a></h5>
<p>An additional module was created which leverages the libiio python bindings call
<a class="reference internal" href="../pyadi-iio/index.html#pyadi-iio"><span class="std std-ref">pyadi-iio</span></a>.
pyadi-iio is recommended if a device specific class exists for your
<a class="icon git reference external" href="https://github.com/analogdevicesinc/pyadi-iio/tree/main/supported_parts.md">current hardware</a>.
However, since pyadi-iio uses libiio all the libiio python APIs are available in
that module if needed.</p>
</section>
</section>
<section id="c-bindings">
<h4>C# bindings<a class="headerlink" href="#c-bindings" title="Link to this heading"></a></h4>
<p>The C# bindings in particular are fully functional and cover the whole panel of
features that libiio provides. Its API consists in the Context, Device, Channel
and IOBuffer classes, each one providing a couple of methods, that directly call
their C counterpart:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">iio</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">Device</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="n">IntPtr</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span>
<span class="w">        </span><span class="p">...</span>

<span class="w">        </span><span class="na">[DllImport(&quot;libiio.dll&quot;, CallingConvention = CallingConvention.Cdecl)]</span>
<span class="w">        </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="n">IntPtr</span><span class="w"> </span><span class="nf">iio_device_get_id</span><span class="p">(</span><span class="n">IntPtr</span><span class="w"> </span><span class="n">dev</span><span class="p">);</span>

<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="kt">string</span><span class="w"> </span><span class="nf">id</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">Marshal</span><span class="p">.</span><span class="n">PtrToStringAnsi</span><span class="p">(</span><span class="n">iio_device_get_id</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, if you call the id method on an object of type Device, as a
result the C function iio_device_get_id will be called. All the others methods
implement a similar mechanism.</p>
<p>The C# bindings are especially interesting for Windows users, because they
permit to use libiio in a .NET application (with the network backend, of
course). By using Mono, it is also possible to use libiio in C# programs running
on Linux.</p>
</section>
</section>
<section id="future-improvements">
<h3>Future improvements<a class="headerlink" href="#future-improvements" title="Link to this heading"></a></h3>
<section id="zerocopy">
<h4>Zerocopy<a class="headerlink" href="#zerocopy" title="Link to this heading"></a></h4>
<p>The current version of the IIOD server is extremely fast, provided that
client-side demultiplexing is used. On a weak 400 MHz CPU, it has no problems to
stream samples at speeds of 3MSPS (3 million samples per second) without
dropping a single one.</p>
<p>However, 3 MSPS is really far from the maximum capacity of the typical
converters. The
<a class="reference external" href="https://wiki.analog.com/resources/eval/user-guides/ad-fmcomms3-ebz/">AD-FMCOMMS3-EBZ</a> board, for
instance, can digitize at a speed up to 61.44 MSPS (time 4 channels, for a total
of 245.76 MSPS) … nearly 100 times faster. And the recent
<a class="reference external" href="https://wiki.analog.com/resources/eval/user-guides/ad-fmcdaq2-ebz/">AD-FMCDAQ2-EBZ</a> is capable of
1000 MSPS for dual 16-bit channels, which represents a maximum transfer speed of
2000 MSPS, or 32.0 Gb/s.</p>
<p>So how to reach those extremely high speeds, with a 400 MHz CPU? That’s where
<a class="reference external" href="https://en.wikipedia.org/wiki/Zero-copy">Zero copy</a> comes in play. To
understand what zerocopy is, and how useful it can be, let’s quickly recall how
the IIOD uploads the samples from one device to a connected client:</p>
<ul class="simple">
<li><p>When the low-speed interface is used, the samples are acquired from the
hardware using DMA, and stored into a kernel buffer; the local backend of
libiio will then use the CPU to copy the samples to the iio_buffer object,
and then copy again to the packet buffer of the Linux kernel by writing the
client’s socket.</p></li>
</ul>
<a class="reference internal image-reference" href="../../_images/libiio_route_lowspeed.png"><img alt="../../_images/libiio_route_lowspeed.png" src="../../_images/libiio_route_lowspeed.png" style="width: 600px;" />
</a>
<ul class="simple">
<li><p>The high-speed interface works roughly the same, but the manual copy from the
kernel’s IIO buffer to the iio_buffer object is avoided by swapping the
buffers from user space and kernel space. However, it is still required to
write the buffer to each client’s socket.</p></li>
</ul>
<a class="reference internal image-reference" href="../../_images/libiio_route_highspeed.png"><img alt="../../_images/libiio_route_highspeed.png" src="../../_images/libiio_route_highspeed.png" style="width: 600px;" />
</a>
<ul>
<li><p>Then comes zerocopy. The principle, is to avoid the second manual copy of the
samples, when the data is written to the socket. So how can this work? How is
it possible to send data through the network, without writing the socket?
The answer is to be found deep inside the Linux kernel. A particular system
call, named
“<a class="reference external" href="https://en.wikipedia.org/wiki/Splice_(system_call)">vmsplice</a>”,
allows to “give” virtual pages of memory to the Linux kernel through a file
descriptor. This trick, introduced in Linux 2.6.17, works by re-configuring
the Memory Management Unit of the CPU. Let’s say the buffer to write to the
socket starts at address 0x4000; the vmsplice system call will map the exact
same area to a different address in kernel space, e.g. 0x8000, so that the
buffer can be addressed from both addresses. Then, it will re-map the
original 0x4000 address to point to a different physical location. As a
result, a complete buffer of samples has been moved to kernel space, without
copying a single byte of it! Then, from the hardware to the network link, the
CPU never has to copy anything, and the 400 MHz ARM board can push hundreds
of megabytes of samples on the network while having a CPU usage staying close
to zero.</p>
<a class="reference internal image-reference" href="../../_images/libiio_route_zerocopy.png"><img alt="../../_images/libiio_route_zerocopy.png" src="../../_images/libiio_route_zerocopy.png" style="width: 600px;" />
</a>
<p>While vmsplice moves the pages to kernel space, it is also possible to
duplicate them using the “tee” system call, and serve the same data to
multiple clients connected to the IIOD server without using the CPU at all
once again.
This very interesting feature of the kernel doesn’t come without drawbacks:
the address and the size of the buffer must be aligned to the page size for
it to work. It is also uncertain how the IIO drivers within the Linux kernel
would cope with this feature; but that is certainly something that will be
attempted in the future.</p>
</li>
</ul>
</section>
</section>
</section>
</section>


          </div>
              <div class="related">
                &nbsp;
    <a href="index.html" title="Previous document (Alt+Shift+LeftArrow)" class="prev">Libiio</a>
    <a href="cli.html" title="Next document (Alt+Shift+RightArrow)" class="next">Libiio command line utility</a>
              </div>
          
        </div>
      </div>
  </div>

  <label id="cancel-area-show-toc" for="input-show-toc"></label>
  <label id="cancel-area-show-localtoc" for="input-show-localtoc"></label>
    <footer>
      &#169;2024, Analog Devices, Inc.
      
      |
      Made with <a href="https://www.sphinx-doc.org/">Sphinx</a>
      &amp; <a href="https://github.com/analogdevicesinc/doctools">Doctools</a>
      
    </footer>
  </body>
</html>